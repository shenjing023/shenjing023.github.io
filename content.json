{"meta":{"title":"023 Blog","subtitle":"成长","description":null,"author":"神经023","url":"https://github.com/shenjing023"},"pages":[{"title":"categories","date":"2017-03-20T13:18:38.000Z","updated":"2017-03-20T13:18:54.201Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/shenjing023/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-03-20T13:17:13.000Z","updated":"2017-03-20T13:17:58.868Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/shenjing023/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"深入理解C++的动态绑定与静态绑定","slug":"深入理解C++的动态绑定与静态绑定","date":"2017-06-13T13:31:47.822Z","updated":"2017-06-13T13:31:29.652Z","comments":true,"path":"2017/06/13/深入理解C++的动态绑定与静态绑定/","link":"","permalink":"https://github.com/shenjing023/2017/06/13/深入理解C++的动态绑定与静态绑定/","excerpt":"","text":"&ensp;&ensp;C++的多态性，使用了的动态绑定与静态绑定，理解它们的区别有助于更好的理解多态性，以及在变成过程中避免错误，需要理解四个名词：1、对象的静态类型：对象在声明时采用的类型。是在编译期确定的。2、对象的动态类型：目前所指对象的类型，是在运行期决定的。&ensp;&ensp;对象的动态可以更改，但静态类型无法更改。关于对象的静态与动态类型，看一示例：12345678910111213class B&#123;&#125;class C:public B&#123;&#125;class D:public B&#123;&#125;D *pD=new D(); //pD的静态类型是它声明的类型D*，动态类型也是D*B *pB=pD; //pB的静态类型是它声明的类型B*，动态类型是pB所指向的对象pD的类型D*C *pC=new C();pB=pC; //pB的动态类型是可以更改的，现在它的动态类型是C* 3、静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。4、动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。123456789101112131415161718class B&#123; void doSomething(); virtual void vfun();&#125;class C:public B&#123; //子类重新定义了父类的no-virtual函数，这是一个不好的设计，会导致名称遮掩；这里只是为了说明动态绑定和静态绑定才这样使用 void doSomething(); virtual void vfun();&#125;class D:public B&#123; void doSomething(); virtual void vfun();&#125;D *pD=new D();B *pB=pD; 让我们看一下，pD-&gt;doSomething()和pB-&gt;doSomething()调用的是同一个函数吗？不是的，虽然pD和pB都指向同一个对象。因为函数doSomething是一个no-virtual函数，它是静态绑定的，也就是编译器会在编译期根据对象的静态类型来选择函数。pD的静态类型是D，那么编译器在处理pD-&gt;doSomething()的时候会将它指向D::doSomething()。同理，pB的静态类型是B，那pB-&gt;doSomething()调用的就是B::doSomething()。 让我们再来看一下，pD-&gt;vfun()和pB-&gt;vfun()调用的是同一个函数吗？是的。因为vfun是一个虚函数，它动态绑定的，也就是说它绑定的是对象的动态类型，pB和pD虽然静态类型不同，但是他们同时指向一个对象，他们的动态类型是相同的，都是D*，所以，他们的调用的是同一个函数：D::vfun()。 上面都是针对对象指针的情况，对于引用（reference）的情况同样适用。 指针和引用的动态类型和静态类型可能会不一致，但是对象的动态类型和静态类型是一致的。12D D;D.doSomething()和D.vfun()永远调用的都是D::doSomething()和D::vfun() 至于那些事动态绑定，那些事静态绑定，有篇文章总结的非常好：只有虚函数才使用的是动态绑定，其他的全部是静态绑定。 特别需要注意的地方当缺省参数和虚函数一起出现的时候情况有点复杂，极易出错。我们知道，虚函数是动态绑定的，但是为了执行效率，缺省参数是静态绑定的。 123456789101112class B&#123; virtual void vfun(int i=10);&#125;class D:public B&#123; virtual void vfun(int i=20);&#125;D *pD=new D();B *pB=pD;pD-&gt;vfun();pB-&gt;vfun(); 有上面的分析可知pD-&gt;vfun()和pB-&gt;vfun()调用都是函数D::vfun()，但是他们的缺省参数是多少？分析一下，缺省参数是静态绑定的，pD-&gt;vfun()时，pD的静态类型是D*，所以它的缺省参数应该是20；同理，pB-&gt;vfun()的缺省参数应该是10。 摘自：https://www.oschina.net/question/54100_20313","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://github.com/shenjing023/tags/c/"}]},{"title":"Effective C++读书笔记","slug":"Effective C++读书笔记","date":"2017-06-13T13:26:10.170Z","updated":"2017-06-13T13:25:55.535Z","comments":true,"path":"2017/06/13/Effective C++读书笔记/","link":"","permalink":"https://github.com/shenjing023/2017/06/13/Effective C++读书笔记/","excerpt":"","text":"条款02：尽量以const，enum，inline替换#define 请记住 对于单纯常量，最好以const对象或enums替换#define 对于形似函数的宏(macros)，最好改用inline函数替换#define###条款03：尽可能使用const&ensp;&ensp;const可以用在classes外部修饰global或namespace作用域中的常量，或修饰文件、函数、或区块作用域(block space)中被声明为static的对象，也可以用它修饰classes内部的static和non-static成员变量。对于指针，可以指出指针自身、指针所指物，或两者都(或都不)是const：12345char greeting[]=\"hello\";char *p=greeting; //non-const pointer,non-const dataconst char *p=greeting; //non-const pointer,const datachar* const p=greeting; //const pointer,non-const dataconst char* const p=greeting; //const pointer,const data &ensp;&ensp;关键字const出现在号左边，表示被指物是常量；出现在号右边，表示指针自身是常量；出现在*号两边，表示被指物和指针两者都是常量。 请记住 将某些东西声明为const可帮助编译器侦测出错误用法，const可被施加于任何作用域的对象、函数参数、函数返回类型、成员函数本体。 编译器强制实施bitwise constness，但编写程序时应该使用“概念上的常量性”(conceptual constness)。 当const和non-const成员函数有着是指等价的实现时，另non-const版本调用const版本可避免代码重复。 条款4：确定对象使用前先被初始化&ensp;&ensp;有些情况下即使面对的成员变量属于内置类型(那么其初始值或赋值的成本相同)，也一定得使用初值列。如果成员变量是const或references，那就一定需要初值，不能被赋值(见条款5)。为避免需要记住成员变量何时必须在成员初值列中初始化，何时不需要，最简单的做法是：总是使用成员初值列，这样做有时候绝对必要，且有往往比赋值更高效。&ensp;&ensp;C++有着十分固定的“成员初始化次序”，次序总是相同：base classes更早于其derived classes被初始化(见条款12)，而class的长远变量总是以其声明次序被初始化。当成员初值列中条件各个成员时，最好总是以其声明次序为次序。 条款5：了解C++默默编写并调用哪些函数 请记住 (c++98)编译器可以暗自为default构造函数、copy构造函数、copy assignment操作符，以及析构函数。(c++11)新添加了两个特殊成员函数:移动构造函数和移动赋值算子。 &ensp;&ensp;如果在一个“内含reference成员”的class内只吃赋值操作(assignment)，必须自定义copy assignment操作符。“内含const成员”的class也是一样，更改const成员是不合法的，所以编译器不知道如何在它自己生成的赋值函数内面对它们。最后还有一种情况：如果某个base classes将copy assignment操作符声明为private，编译器将拒绝为其derived classes生成一个copy assignment操作符。&ensp;&ensp;c++11禁用拷贝构造函数和赋值构造函数，可在想要 “禁止使用” 的函数声明后加 “= delete”，而需要保留的加 “= default” 或者不采取操作。 条款7：为多态基类声明virtual析构函数 请记住 polymorphic（带多态性质的）base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。 Classes的设计目的如果不是作为base classes使用，或不是为了具备多态性（polymorphically），就不该声明析构函数。 条款9：绝不在构造和析构过程中调用virtual函数 请记住 在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class（比起当前执行构造函数和析构函数的那层） 条款10：令operator=返回一个reference to *this 请记住 令赋值（assignment）操作符返回一个reference to *this。 条款20：宁以pass-by-reference-to-const替换pass-by-value 请记住 尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题（slicing problem） 以上规则并不适用于内置类型，以及STL的迭代器对象。对它们而言，pass-by-value往往比较合适 条款36：绝不重新定义继承而来的non-virtual函数条款37：绝不重新定义继承而来的缺省参数值","categories":[],"tags":[{"name":"Effective C++;mysql","slug":"Effective-C-mysql","permalink":"https://github.com/shenjing023/tags/Effective-C-mysql/"}]},{"title":"python 3.5.2安装mysql驱动报错","slug":"python 3.5.2安装mysql驱动报错","date":"2017-06-12T14:24:27.628Z","updated":"2017-06-12T15:41:17.950Z","comments":true,"path":"2017/06/12/python 3.5.2安装mysql驱动报错/","link":"","permalink":"https://github.com/shenjing023/2017/06/12/python 3.5.2安装mysql驱动报错/","excerpt":"","text":"python 3.5.2安装mysql驱动时出现如下异常: 这是由于官方驱动暂时只支持到python3.4所致，改用pymysql 例子：建表1234567CREATE TABLE `users`( `id` int(11) NOT NULL AUTO_INCREMENT, `email` varchar(255) COLLATE utf8_bin NOT NULL, `password` varchar(255) COLLATE utf8_bin NOT NULL, PRIMARY KEY (`id`))ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_binAUTO_INCREMENT=1; 123456789101112131415161718192021222324import pymysql.cursors#connect to the databaseconnection=pymysql.connect(host='localhost', user='user', password='passwd', db='db', charset='utf8mb4', cursorclass=pymysql.cursors.DictCursor)try: with connection.cursor() as cursor: #Create a new record sql=\"INSERT INTO `users` (`email`,`password`) VALUES (%s,%s)\" cursor.execute(sql,('webmaster@python.org', 'very-secret') #connection is not autocommit by default.So you must commit to save #your changes. connection.commit() with connection.cursor() as cursor: #Read a single record sql=\"SELECT `id`,`password` FROM `users` WHERE `email`=%s\" cursor.execute(sql,('webmaster@python.org',)) result=cursor.fetchone() print(result)finally: connection.close() This example will print:1&#123;'password':'very-secret','id':1&#125; 参考文档 https://github.com/PyMySQL/PyMySQL/","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://github.com/shenjing023/tags/mysql/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-20T12:47:07.406Z","updated":"2017-03-20T15:30:34.309Z","comments":true,"path":"2017/03/20/hello-world/","link":"","permalink":"https://github.com/shenjing023/2017/03/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Postsadasdas\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"sjs","slug":"sjs","permalink":"https://github.com/shenjing023/tags/sjs/"}]}]}