{"meta":{"title":"023 Blog","subtitle":"成长","description":null,"author":"神经023","url":"https://github.com/shenjing023"},"pages":[{"title":"categories","date":"2017-03-20T13:18:38.000Z","updated":"2017-03-20T13:18:54.201Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/shenjing023/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-03-20T13:17:13.000Z","updated":"2017-03-20T13:17:58.868Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/shenjing023/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"学习Scrapy入门","slug":"学习Scrapy入门","date":"2017-06-25T09:40:38.583Z","updated":"2017-06-25T09:50:52.657Z","comments":true,"path":"2017/06/25/学习Scrapy入门/","link":"","permalink":"https://github.com/shenjing023/2017/06/25/学习Scrapy入门/","excerpt":"","text":"Scrapy介绍Scrapy入门Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。所谓网络爬虫，就是一个在网上到处或定向抓取数据的程序，当然，这种说法不够专业，更专业的描述就是，抓取特定网站网页的HTML数据。抓取网页的一般方法是，定义一个入口页面，然后一般一个页面会有其他页面的URL，于是从当前页面获取到这些URL加入到爬虫的抓取队列中，然后进入到新页面后再递归的进行上述的操作，其实说来就跟深度遍历或广度遍历一样。Scrapy 使用 Twisted这个异步网络库来处理网络通讯，架构清晰，并且包含了各种中间件接口，可以灵活的完成各种需求。 整体架构 引擎(Scrapy Engine)，用来处理整个系统的数据流处理，触发事务。 调度器(Scheduler)，用来接受引擎发过来的请求，压入队列中，并在引擎再次请求的时候返回。 下载器(Downloader)，用于下载网页内容，并将网页内容返回给蜘蛛。 蜘蛛(Spiders)，蜘蛛是主要干活的，用它来制订特定域名或网页的解析规则。编写用于分析response并提取item(即获取到的item)或额外跟进的URL的类。 每个spider负责处理一个特定(或一些)网站。 项目管道(Item Pipeline)，负责处理有蜘蛛从网页中抽取的项目，他的主要任务是清晰、验证和存储数据。当页面被蜘蛛解析后，将被发送到项目管道，并经过几个特定的次序处理数据。 下载器中间件(Downloader Middlewares)，位于Scrapy引擎和下载器之间的钩子框架，主要是处理Scrapy引擎与下载器之间的请求及响应。 蜘蛛中间件(Spider Middlewares)，介于Scrapy引擎和蜘蛛之间的钩子框架，主要工作是处理蜘蛛的响应输入和请求输出。 调度中间件(Scheduler Middlewares)，介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。爬取流程上图绿线是数据流向，首先从初始URL开始，Scheduler会将其交给Downloader进行下载，下载之后会交给Spider进行分析，Spider分析出来的结果有两种：一种是需要进一步抓取的链接，这些东西会被传回Scheduler；另一种是需要保存的数据，它们则被送到Item Pipeline那里，那是对数据进行后期处理（详细分析、过滤、存储等）的地方。另外，在数据流动的通道里还可以安装各种中间件，进行必要的处理。数据流Scrapy中的数据流由执行引擎控制，其过程如下: 引擎打开一个网站(open a domain)，找到处理该网站的Spider并向该spider请求第一个要爬取的URL(s)。 引擎从Spider中获取到第一个要爬取的URL并在调度器(Scheduler)以Request调度。 引擎向调度器请求下一个要爬取的URL。 调度器返回下一个要爬取的URL给引擎，引擎将URL通过下载中间件(请求(request)方向)转发给下载器(Downloader)。 一旦页面下载完毕，下载器生成一个该页面的Response，并将其通过下载中间件(返回(response)方向)发送给引擎。 引擎从下载器中接收到Response并通过Spider中间件(输入方向)发送给Spider处理。 Spider处理Response并返回爬取到的Item及(跟进的)新的Request给引擎。 引擎将(Spider返回的)爬取到的Item给Item Pipeline，将(Spider返回的)Request给调度器。 (从第二步)重复直到调度器中没有更多地request，引擎关闭该网站。Scrapy项目基本流程默认的Scrapy项目结构使用全局命令startproject创建项目scrapy startproject tutorial 即可自动创建官方标准的代码目录。 其中: tutorial/:该项目的python总模块 scrapy.cfg:项目的配置文件 tutorial/items.py:项目中的item文件，编写爬取的字段名称 tutorial/pipelines.py: 项目中的pipelines文件 utorial/settings.py: 项目的设置文件，较为重要 tutorial/spiders/: 放置spider代码的主目录 定义要抓取的数据Item是保存爬取到的数据的容器，其实用方法和python字典类似，并且提供了额外保护机制来避免瓶邪错误导致的未定义字段错误。 编写提取item数据的SpiderSpider是用户编写用于从单个网站(或者一些网站)爬取数据的类。其包含了一个用于下载的初始URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。为了创建一个Spider，必须继承 scrapy.Spider 类，且定义以下三个属性: name:用于区别Spider，该名字必须是唯一的，不可以为不同的Spider设定相同的名字。 start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一， 后续的URL则从初始的URL获取到的数据中提取。 parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。 进行爬取执行项目命令crawl，启动Spider scrapy crawl tutorial 在这个过程中：Scrapy为Spider的 start_urls 属性中的每个URL创建了 scrapy.Request 对象，并将 parse 方法作为回调函数(callback)赋值给了Request。Request对象经过调度，执行生成 scrapy.http.Response 对象并送回给spider parse() 方法。","categories":[],"tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://github.com/shenjing023/tags/scrapy/"}]},{"title":"深入理解C++的动态绑定与静态绑定","slug":"深入理解C++的动态绑定与静态绑定","date":"2017-06-13T13:31:47.822Z","updated":"2017-06-13T13:31:29.652Z","comments":true,"path":"2017/06/13/深入理解C++的动态绑定与静态绑定/","link":"","permalink":"https://github.com/shenjing023/2017/06/13/深入理解C++的动态绑定与静态绑定/","excerpt":"","text":"&ensp;&ensp;C++的多态性，使用了的动态绑定与静态绑定，理解它们的区别有助于更好的理解多态性，以及在变成过程中避免错误，需要理解四个名词：1、对象的静态类型：对象在声明时采用的类型。是在编译期确定的。2、对象的动态类型：目前所指对象的类型，是在运行期决定的。&ensp;&ensp;对象的动态可以更改，但静态类型无法更改。关于对象的静态与动态类型，看一示例：12345678910111213class B&#123;&#125;class C:public B&#123;&#125;class D:public B&#123;&#125;D *pD=new D(); //pD的静态类型是它声明的类型D*，动态类型也是D*B *pB=pD; //pB的静态类型是它声明的类型B*，动态类型是pB所指向的对象pD的类型D*C *pC=new C();pB=pC; //pB的动态类型是可以更改的，现在它的动态类型是C* 3、静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。4、动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。123456789101112131415161718class B&#123; void doSomething(); virtual void vfun();&#125;class C:public B&#123; //子类重新定义了父类的no-virtual函数，这是一个不好的设计，会导致名称遮掩；这里只是为了说明动态绑定和静态绑定才这样使用 void doSomething(); virtual void vfun();&#125;class D:public B&#123; void doSomething(); virtual void vfun();&#125;D *pD=new D();B *pB=pD; 让我们看一下，pD-&gt;doSomething()和pB-&gt;doSomething()调用的是同一个函数吗？不是的，虽然pD和pB都指向同一个对象。因为函数doSomething是一个no-virtual函数，它是静态绑定的，也就是编译器会在编译期根据对象的静态类型来选择函数。pD的静态类型是D，那么编译器在处理pD-&gt;doSomething()的时候会将它指向D::doSomething()。同理，pB的静态类型是B，那pB-&gt;doSomething()调用的就是B::doSomething()。 让我们再来看一下，pD-&gt;vfun()和pB-&gt;vfun()调用的是同一个函数吗？是的。因为vfun是一个虚函数，它动态绑定的，也就是说它绑定的是对象的动态类型，pB和pD虽然静态类型不同，但是他们同时指向一个对象，他们的动态类型是相同的，都是D*，所以，他们的调用的是同一个函数：D::vfun()。 上面都是针对对象指针的情况，对于引用（reference）的情况同样适用。 指针和引用的动态类型和静态类型可能会不一致，但是对象的动态类型和静态类型是一致的。12D D;D.doSomething()和D.vfun()永远调用的都是D::doSomething()和D::vfun() 至于那些事动态绑定，那些事静态绑定，有篇文章总结的非常好：只有虚函数才使用的是动态绑定，其他的全部是静态绑定。 特别需要注意的地方当缺省参数和虚函数一起出现的时候情况有点复杂，极易出错。我们知道，虚函数是动态绑定的，但是为了执行效率，缺省参数是静态绑定的。 123456789101112class B&#123; virtual void vfun(int i=10);&#125;class D:public B&#123; virtual void vfun(int i=20);&#125;D *pD=new D();B *pB=pD;pD-&gt;vfun();pB-&gt;vfun(); 有上面的分析可知pD-&gt;vfun()和pB-&gt;vfun()调用都是函数D::vfun()，但是他们的缺省参数是多少？分析一下，缺省参数是静态绑定的，pD-&gt;vfun()时，pD的静态类型是D*，所以它的缺省参数应该是20；同理，pB-&gt;vfun()的缺省参数应该是10。 摘自：https://www.oschina.net/question/54100_20313","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://github.com/shenjing023/tags/c/"}]},{"title":"Effective C++读书笔记","slug":"Effective C++读书笔记","date":"2017-06-13T13:26:10.170Z","updated":"2017-06-13T13:33:29.002Z","comments":true,"path":"2017/06/13/Effective C++读书笔记/","link":"","permalink":"https://github.com/shenjing023/2017/06/13/Effective C++读书笔记/","excerpt":"","text":"条款02：尽量以const，enum，inline替换#define 请记住 对于单纯常量，最好以const对象或enums替换#define 对于形似函数的宏(macros)，最好改用inline函数替换#define###条款03：尽可能使用const&ensp;&ensp;const可以用在classes外部修饰global或namespace作用域中的常量，或修饰文件、函数、或区块作用域(block space)中被声明为static的对象，也可以用它修饰classes内部的static和non-static成员变量。对于指针，可以指出指针自身、指针所指物，或两者都(或都不)是const：12345char greeting[]=\"hello\";char *p=greeting; //non-const pointer,non-const dataconst char *p=greeting; //non-const pointer,const datachar* const p=greeting; //const pointer,non-const dataconst char* const p=greeting; //const pointer,const data &ensp;&ensp;关键字const出现在号左边，表示被指物是常量；出现在号右边，表示指针自身是常量；出现在*号两边，表示被指物和指针两者都是常量。 请记住 将某些东西声明为const可帮助编译器侦测出错误用法，const可被施加于任何作用域的对象、函数参数、函数返回类型、成员函数本体。 编译器强制实施bitwise constness，但编写程序时应该使用“概念上的常量性”(conceptual constness)。 当const和non-const成员函数有着是指等价的实现时，另non-const版本调用const版本可避免代码重复。 条款4：确定对象使用前先被初始化&ensp;&ensp;有些情况下即使面对的成员变量属于内置类型(那么其初始值或赋值的成本相同)，也一定得使用初值列。如果成员变量是const或references，那就一定需要初值，不能被赋值(见条款5)。为避免需要记住成员变量何时必须在成员初值列中初始化，何时不需要，最简单的做法是：总是使用成员初值列，这样做有时候绝对必要，且有往往比赋值更高效。&ensp;&ensp;C++有着十分固定的“成员初始化次序”，次序总是相同：base classes更早于其derived classes被初始化(见条款12)，而class的长远变量总是以其声明次序被初始化。当成员初值列中条件各个成员时，最好总是以其声明次序为次序。 条款5：了解C++默默编写并调用哪些函数 请记住 (c++98)编译器可以暗自为default构造函数、copy构造函数、copy assignment操作符，以及析构函数。(c++11)新添加了两个特殊成员函数:移动构造函数和移动赋值算子。 &ensp;&ensp;如果在一个“内含reference成员”的class内只吃赋值操作(assignment)，必须自定义copy assignment操作符。“内含const成员”的class也是一样，更改const成员是不合法的，所以编译器不知道如何在它自己生成的赋值函数内面对它们。最后还有一种情况：如果某个base classes将copy assignment操作符声明为private，编译器将拒绝为其derived classes生成一个copy assignment操作符。&ensp;&ensp;c++11禁用拷贝构造函数和赋值构造函数，可在想要 “禁止使用” 的函数声明后加 “= delete”，而需要保留的加 “= default” 或者不采取操作。 条款7：为多态基类声明virtual析构函数 请记住 polymorphic（带多态性质的）base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。 Classes的设计目的如果不是作为base classes使用，或不是为了具备多态性（polymorphically），就不该声明析构函数。 条款9：绝不在构造和析构过程中调用virtual函数 请记住 在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class（比起当前执行构造函数和析构函数的那层） 条款10：令operator=返回一个reference to *this 请记住 令赋值（assignment）操作符返回一个reference to *this。 条款20：宁以pass-by-reference-to-const替换pass-by-value 请记住 尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题（slicing problem） 以上规则并不适用于内置类型，以及STL的迭代器对象。对它们而言，pass-by-value往往比较合适 条款36：绝不重新定义继承而来的non-virtual函数条款37：绝不重新定义继承而来的缺省参数值","categories":[],"tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://github.com/shenjing023/tags/Effective-C/"}]},{"title":"python 3.5.2安装mysql驱动报错","slug":"python 3.5.2安装mysql驱动报错","date":"2017-06-12T14:24:27.628Z","updated":"2017-06-12T15:41:17.950Z","comments":true,"path":"2017/06/12/python 3.5.2安装mysql驱动报错/","link":"","permalink":"https://github.com/shenjing023/2017/06/12/python 3.5.2安装mysql驱动报错/","excerpt":"","text":"python 3.5.2安装mysql驱动时出现如下异常: 这是由于官方驱动暂时只支持到python3.4所致，改用pymysql 例子：建表1234567CREATE TABLE `users`( `id` int(11) NOT NULL AUTO_INCREMENT, `email` varchar(255) COLLATE utf8_bin NOT NULL, `password` varchar(255) COLLATE utf8_bin NOT NULL, PRIMARY KEY (`id`))ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_binAUTO_INCREMENT=1; 123456789101112131415161718192021222324import pymysql.cursors#connect to the databaseconnection=pymysql.connect(host='localhost', user='user', password='passwd', db='db', charset='utf8mb4', cursorclass=pymysql.cursors.DictCursor)try: with connection.cursor() as cursor: #Create a new record sql=\"INSERT INTO `users` (`email`,`password`) VALUES (%s,%s)\" cursor.execute(sql,('webmaster@python.org', 'very-secret') #connection is not autocommit by default.So you must commit to save #your changes. connection.commit() with connection.cursor() as cursor: #Read a single record sql=\"SELECT `id`,`password` FROM `users` WHERE `email`=%s\" cursor.execute(sql,('webmaster@python.org',)) result=cursor.fetchone() print(result)finally: connection.close() This example will print:1&#123;'password':'very-secret','id':1&#125; 参考文档 https://github.com/PyMySQL/PyMySQL/","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://github.com/shenjing023/tags/mysql/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-20T12:47:07.406Z","updated":"2017-03-20T15:30:34.309Z","comments":true,"path":"2017/03/20/hello-world/","link":"","permalink":"https://github.com/shenjing023/2017/03/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Postsadasdas\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"sjs","slug":"sjs","permalink":"https://github.com/shenjing023/tags/sjs/"}]}]}